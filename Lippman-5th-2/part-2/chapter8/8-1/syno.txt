getline() - получает ссылку на обьект класса istream и читает слово из потока ввода в строку.
заголовок fstream - чтение и запись в именованные файлы.
sstream - чтение и запись в строки, расположенные в ОП.
Заголовки чтения и записи расширенных символов соответствуют w<nameofh>
istringstream и ifstream наследованы от класса istream.
Соответственно их можно использовать как класс istream. (принцип наследования)
Когда идёт речь о потоках, они работают как с обычными символами, так и с wchar_t.

    8.1.1 Обьекты ввода и вывода не допускают копирования и присвоения.
Функции, использующие потоки ввода-вывода принимают их как ссылки.
Такая ссылка не может быть константной.

    8.1.2 Флаги состояния
Из-за наследования классов, могут возникать ошибки.
Существует ряд флагов, с помощью которых можно манипулировать потоком ввода-вывода.
Таблица 8-2.
image.png
Читать и записывать в поток можно при условии того, что все флаги находятся в допустимом состоянии.

while (cin >> j)
    // continue if istream is able

Достижение конца потока устанавливает флаги eofbit и failbit.
Корректный способ определения допустимости потока - функции good() и fail().

    8.1.3 Управление буфером вывода
Каждый обьект ввода-вывода управляет буфером, используемым для хранения данных.
Несолько условий для сброса буфера:
- Программа завершается нормально, все буферы освобождаются при выходе из main
- Если буфер заполнен - сброс буфера
- endl
- используя unitbuf можно сделать так, чтобы буфер сбрасывался после каджого вывода
Существует несолько способов сбросить буфер при выводе.

std::cout << "hi" << endl; // Added \n to the end
std::cout << "hi" << flush; // Reset the buffer
std::cout << "hi" << ends; // Added \0 to the end and reset the buffer

std::cout << unitbuf; // reset the buffer every out
std::cout << nounitbuf; // reset to default bufferisation

Буфер ввода не сбрасывается, если программа завершается аварийно.

std::cin.tie(&cout) // link cout and cin

Чтобы разорвать созданную с помощью tie связь, необходимо передать значение 0.
