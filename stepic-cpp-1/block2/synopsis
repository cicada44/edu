    2.1 Архитектура фон Неймана
Принципы архитектуры:
    -принцип однородности памяти - память хранит как команды, так и данные
    -принцип адресности - состоит из пронумерованных ячеек
    -принцип программного управления - все вычисления в виде последовательности
    -принцип двоичного кодирования - данные кодируются двоичными числами
2 области памяти - семент данных, сегмент кода
В сегменте данных располагаются данные программы
При запуске выделяются 2 сегмента: сегмент глобальных переменных, стек
В процессе работы доп. сегменты могут выделяться и освобождаться
1 секция памяти - функция (имеет свой адрес)
Компиляция - в места вызова подставляются имена
Линковка - вместо имёт подставляются их адреса

    2.2 Стек вызовов
В стеке хранятся локальные переменные
При выходе из функции вся память на стеке освобождается
В архитектуре x86 стек растёт сверху вниз
Всегда стоит инициализировать переменные в функциях, так как
при освобождении памяти из под функции и инициализации переменной в другой
может произойти наложение
Аргументы, переданные в функцию адресуются в обратном порядке

    2.3 Массивы и указатели
int p = &s;
int arr[3] = {1,2,3};

    2.4 Использование указателей
Реализации функций работы с массивами работают быстрее с указателям

    2.5 Ссылки
Недостатки указателей:
    -загрязнаяет код
    -можно использовать неинициализированным
    -необходимо проверять на 0
    -арифметика указателей не учитывает возможного выхода за границу
Ссылки - красивая обертка вокруг указателей
Ссылка - &
int &l = a; - l ссылается на a
Ссылки не могут быть переинициализированы или неинициализированы
Нельзя также получить адрес ссылки или ссылку на ссылку, нельзя создавать
массивы ссылок. Для ссылок также нет арифметики.
Реализуют идею "синонимов"
В С++ существует 2 типа выражений:
    -rvalue - выражения, которые являются ссылкой на переменную, могут быть
     указаты слева от оператора =
    -lvalue - выражения, значения которых являются временными и не соответствуют
     никакой переменной или элементу массива
void foo(int (&a)[3]) { /*...*/} - передача ссылки на массив в функцию
Ссылки в С++ используются также для передачи "больших" аргументов

    2.6 Динамическая память
Стек программы ограничен, динамическая память управляется вручную
Выделение памяти в стиле С++
new сразу же возвращает типизированный указатель
int m = new int[10000];
delete [] m;
int * m = new int(5);
delete m;
Проблема производиельности, фрагментации при выделении динамической памяти
При реинициализации не вызвать delete, произойдет утечка памяти
Утечки памяти - ОЧЕНЬ ПЛОХО
Нельзя совмещать С и С++ функции по работе с памятью

    2.7 Многомерные массивы
Размерность массива может быть любой
Для выделения:
int * m1d = new int [100];
m[i][j] === *(m[i] + j)
int **m = new int*[5]; // Выделение под строки
for (int x=0; x<5;x++) m[i] = new int[4]; // Выделения под значения
